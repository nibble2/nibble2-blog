<!doctype html><html lang=ko dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>클로저 | nibble2</title>
<meta name=keywords content="클로저">
<meta name=description content="들어가며.. 자바스크립트는 함수 지향 언어입니다. 이런 특징은 개발자에게 많은 자유도를 줍니다. 함수를 동적으로 생성할 수 있고, 생성한 함수를 다른 함수에 인수로 넘길 수 있으며, 생성된 곳이 아닌 곳에서 함수를 호출할 수도 있기 때문입니다.
함수 내부에서 함수 외부에 있는 변수에 접근할 수 있다는 사실은 앞서 학습해서 알고 계실 겁니다.
그런데 함수가 생성된 이후에 외부 변수가 변경되면 어떤 일이 발생할까요? 함수는 새로운 값을 가져올까요? 아니면 생성 시점 이전의 값을 가져올까요?
매개변수를 통해 함수를 넘기고 이 함수를 저 멀리 떨어진 코드에서 호출할 땐 어떤 일이 발생할까요?">
<meta name=author content="nibble2">
<link rel=canonical href=https://nibble2.github.io/posts/archives/javascript-deep-dive/24.-%ED%81%B4%EB%A1%9C%EC%A0%80/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://nibble2.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://nibble2.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://nibble2.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://nibble2.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://nibble2.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<meta property="og:title" content="클로저">
<meta property="og:description" content="들어가며.. 자바스크립트는 함수 지향 언어입니다. 이런 특징은 개발자에게 많은 자유도를 줍니다. 함수를 동적으로 생성할 수 있고, 생성한 함수를 다른 함수에 인수로 넘길 수 있으며, 생성된 곳이 아닌 곳에서 함수를 호출할 수도 있기 때문입니다.
함수 내부에서 함수 외부에 있는 변수에 접근할 수 있다는 사실은 앞서 학습해서 알고 계실 겁니다.
그런데 함수가 생성된 이후에 외부 변수가 변경되면 어떤 일이 발생할까요? 함수는 새로운 값을 가져올까요? 아니면 생성 시점 이전의 값을 가져올까요?
매개변수를 통해 함수를 넘기고 이 함수를 저 멀리 떨어진 코드에서 호출할 땐 어떤 일이 발생할까요?">
<meta property="og:type" content="article">
<meta property="og:url" content="https://nibble2.github.io/posts/archives/javascript-deep-dive/24.-%ED%81%B4%EB%A1%9C%EC%A0%80/"><meta property="og:image" content="https://nibble2.github.io/papermod-cover.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-06-29T00:00:00+00:00">
<meta property="article:modified_time" content="2021-06-29T00:00:00+00:00"><meta property="og:site_name" content="https://nibble2.github.io">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://nibble2.github.io/papermod-cover.png">
<meta name=twitter:title content="클로저">
<meta name=twitter:description content="들어가며.. 자바스크립트는 함수 지향 언어입니다. 이런 특징은 개발자에게 많은 자유도를 줍니다. 함수를 동적으로 생성할 수 있고, 생성한 함수를 다른 함수에 인수로 넘길 수 있으며, 생성된 곳이 아닌 곳에서 함수를 호출할 수도 있기 때문입니다.
함수 내부에서 함수 외부에 있는 변수에 접근할 수 있다는 사실은 앞서 학습해서 알고 계실 겁니다.
그런데 함수가 생성된 이후에 외부 변수가 변경되면 어떤 일이 발생할까요? 함수는 새로운 값을 가져올까요? 아니면 생성 시점 이전의 값을 가져올까요?
매개변수를 통해 함수를 넘기고 이 함수를 저 멀리 떨어진 코드에서 호출할 땐 어떤 일이 발생할까요?">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nibble2.github.io/posts/"},{"@type":"ListItem","position":2,"name":"클로저","item":"https://nibble2.github.io/posts/archives/javascript-deep-dive/24.-%ED%81%B4%EB%A1%9C%EC%A0%80/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"클로저","name":"클로저","description":"들어가며.. 자바스크립트는 함수 지향 언어입니다. 이런 특징은 개발자에게 많은 자유도를 줍니다. 함수를 동적으로 생성할 수 있고, 생성한 함수를 다른 함수에 인수로 넘길 수 있으며, 생성된 곳이 아닌 곳에서 함수를 호출할 수도 있기 때문입니다.\n함수 내부에서 함수 외부에 있는 변수에 접근할 수 있다는 사실은 앞서 학습해서 알고 계실 겁니다.\n그런데 함수가 생성된 이후에 외부 변수가 변경되면 어떤 일이 발생할까요? 함수는 새로운 값을 가져올까요? 아니면 생성 시점 이전의 값을 가져올까요?\n매개변수를 통해 함수를 넘기고 이 함수를 저 멀리 떨어진 코드에서 호출할 땐 어떤 일이 발생할까요?","keywords":["클로저"],"articleBody":"들어가며.. 자바스크립트는 함수 지향 언어입니다. 이런 특징은 개발자에게 많은 자유도를 줍니다. 함수를 동적으로 생성할 수 있고, 생성한 함수를 다른 함수에 인수로 넘길 수 있으며, 생성된 곳이 아닌 곳에서 함수를 호출할 수도 있기 때문입니다.\n함수 내부에서 함수 외부에 있는 변수에 접근할 수 있다는 사실은 앞서 학습해서 알고 계실 겁니다.\n그런데 함수가 생성된 이후에 외부 변수가 변경되면 어떤 일이 발생할까요? 함수는 새로운 값을 가져올까요? 아니면 생성 시점 이전의 값을 가져올까요?\n매개변수를 통해 함수를 넘기고 이 함수를 저 멀리 떨어진 코드에서 호출할 땐 어떤 일이 발생할까요? 함수는 호출되는 곳을 기준으로 외부 변수에 접근할까요?\n이젠 이런 간단한 시나리오부터 시작해 좀 더 복잡한 시나리오를 다룰 수 있도록 지식을 확장해 봅시다.\n클로저 ‘클로저(closure)' 는 개발자라면 알고 있어야 할 프로그래밍 용어입니다.\n클로저는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미합니다. 몇 몇 언어에선 클로저를 구현하는 게 불가능하거나 특수한 방식으로 함수를 작성해야 클로저를 만들 수 있습니다. 하지만 자바스크립트에선 모든 함수가 자연스럽게 클로저가 됩니다. 예외가 하나 있긴 한데 자세한 내용은 ‘new Function’ 문법에서 다루도록 하겠습니다.\n요점을 정리해 봅시다. 자바스크립트의 함수는 숨김 프로퍼티인 [[Environment]]를 이용해 자신이 어디서 만들어졌는지를 기억합니다. 함수 내부의 코드는 [[Environment]]를 사용해 외부 변수에 접근합니다.\n프런트엔드 개발자 채용 인터뷰에서 “클로저가 무엇입니까?“라는 질문을 받으면, 클로저의 정의를 말하고 자바스크립트에서 왜 모든 함수가 클로저인지에 관해 설명하면 될 것 같습니다. 이때 [[Environment]] 프로퍼티와 렉시컬 환경이 어떤 방식으로 동작하는지에 대한 설명을 덧붙이면 좋습니다.\n변수의 유효범위와 클로저 함수 내부에서 함수 외부에 있는 변수에 접근할 수 있다는 사실은 맞다.\n그런데 함수가 생성된 이후에 외부 변수가 변경되면 어떤 일이 발생할까?\n 새로운 함수를 가져온다 생성 시점 이전의 값을 가져온다.  또한 매개변수를 통해 함수를 넘기고 이 함수를 저 멀리 떨어진 코드에서 호출할 땐 어떤 일이 발생할까? 함수는 호출 되는 곳을 기준으로 외부 변수에 접근할까?\n중첩함수 function makeCounter() { let count = 0; return function() { return count++; }; } let counter = makeCounter(); alert( counter() ); // 0 alert( counter() ); // 1 alert( counter() ); // 2 그런데 makeCounter를 살펴보다 보면 “counter를 여러 개 만들었을 때, 이 함수들은 서로 독립적일까? 함수와 중첩 함수 내 count 변수엔 어떤 값이 할당될까?” 같은 의문이 들기 마련입니다.\n렉시컬 환경 1단계: 변수  실행중인 함수, 코드블록, 스크립트 전체를 갖는다.\n  환경 레코드(Environment Record)  모든 지역 변수를 프로퍼티로 저장하고 있는 객체이다. this 값과 같은 기타 정보도 여기에 저장된다.    외부 렉시컬 환경(Outer Lexical Environment)에 대한 참조  외부 코드와 연관되어있음     ‘변수’는 특수 내부 객체인 환경 레코드의 프로퍼티일 뿐이다.\n변수를 가져오거나 변경 = 환경 레코드의 프로퍼티를 가져오가나 변경\n  렉시컬 환경이 하나만 존재   👀 한 줄 한 줄 실행될 때마다 어떻게 변화하는지 살펴보자. (네모 상자: 환경 레코드 / 붉은 화살표: 외부 참조)\n 스크립트가 시작되면 선언한 변수 전체가 렉시컬 환경에 올라간다. (pre-populated)  이때 변수의 상태는 특수 내부 상태(special internal state)인 ‘uninitialized’가 됩니다. 자바스크립트 엔진은 ‘uninitialized’ 상태의 변수를 인지하긴 하지만, let을 만나기 전까진 이 변수를 참조할 수 없습니다.   let phrase가 선언되었지만 프로퍼티 값은 undefined이다. 값 할당 값 변경  현재까지 배운 내용 요약 💁‍♀️\n 변수는 특수 내부 객체인 환경 레코드의 프로퍼티이다. 환경 레코드는 현재 실행 중인 함수와 코드 블록, 스크립트와 연관되어 있다. 변수를 변경하면 환경 레코드의 프로퍼티가 변경된다.  렉시컬 환경은 JS가 어떻게 동작하는지 설명하는 데 쓰이는 이론상의 객체이다. 따라서 코드를 사용해 직접 렉시컬 환경을 얻거나 조작하는 것은 불가능하다.\n2단계: 함수 선언문 함수 선언문으로 선언한 함수는 일반 변수와 달리 바로 초기화된다는 점에서 차이가 있다.\n아래 스크립트에 함수를 추가했을 때 전역 렉시컬 환경 초기 상태가 어떻게 변하는지 보여준다.\nlet say = function(name).. 이런 동작 방식은 함수 선언문으로 정의한 함수에만 적용된다. 위와 같이 함수를 변수에 할당한 함수 표현식은 해당하지 않는다.\n3단계: 내부와 외부 렉시컬 환경 함수를 호출해 실행하면 새로운 렉시컬 환경이 자동으로 만들어진다. 이 렉시컬 환경엔 함수 호출 시 넘겨받은 매개변수와 함수의 지역 변수가 저장된다.\n함수가 호출 중인 동안 👀\n 호출 중인 함수를 위한 내부 렉시컬 환경 내부 렉시컬 환경이 가리키는 외부 렉시컬 환경  두개를 갖게 된다.\n  내부 렉시컬 환경 - name : “Jone” / 현재 실행 중인 함수인 say에 상응한다.\n  외부 렉시컬 환경 - say function, phrase : “Hello”\n  코드에서 변수에 접근할 땐, 먼저 내부 렉시컬 환경을 검색 범위로 잡는다 내부 렉시컬 환경에서 원하는 변수를 찾지 못하면 검색 범위를 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 확장한다. 이 과정은 검색 범위가 전역 렉시컬 환경으로 확장될 때까지 반복된다.*\n내부 렉시컬 환경에 name을 찾았지만 phrase를 찾지 못해 외부 렉시컬 환경으로 확장해 검색한다. 4단계 : 반환 함수 function makeCounter() { let count = 0; return function() { return count++; }; } let counter = makeCounter(); makeCounter()를 호출하면 호출할 때 마다 새로운 렉시컬 환경 객체가 만들어진다. 그리고 이 렉시컬 환경 개체 엔 makeCounter를 실행하는데 필요한 변수들도 저장된다.\n여기서 중첩함수(반환 함수)가 만들어지면 어떻게 될까?\n중요한 사실 하나 ❗️\n모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억한다. 🤔 함수는 [[Environment]]라 불리는 숨김 프로퍼티를 갖는데, 여기에 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장된다.\n따.라.서.\ncounter[[Environment]]엔 { counter: 0 }이 있는 렉시컬 환경에 대한 참조가 저장된다.\n 함수가 생성될 때 딱 한 번 그 값이 세팅된다. 이 값은 영원히 바뀌지 않는다.  실행 흐름이 중첩 함수의 본문으로 넘어오면 count 변수가 필요한데, 먼저 자체 렉시컬 환경에서 변수를 찾는다. 익명 중첩 함수엔 지역 변수가 없기 때문에 이 렉시컬 환경은 비어있다. 이제 counter()의 렉시컬 환경이 참조하는 외부 렉시컬 환경에서 count를 찾자.\ncount()를 여러 번 호출하면 count 변수가 2, 3으로 증가하는 이유이다.\n가비지 컬렉션 자바스크립트에서 모든 객체는 도달 가능한 상태일 때만 메모리에 유지되고 나머지는 삭제된다.\n그런데 호출이 끝나도 여전히 도달 가능한 함수가 있을 수 있다. 이때는 중첩함수의 [[Environment]] 프로퍼티에 외부 함수에 대한 렉시컬 환경에 대한 정보가 저장된다\n이론상으로 그렇겠지만 사실 JS엔진이 최적화를 시켜주기 때문에 신경쓰지 않아도 된다.\n하지만 종종 디버깅 이슈가 존재한다.\n클로저의 활용 내부에서 외부 데이터를 사용하고자 할 때 !!  함수를 분리 bind 사용 ⇒ 하지만 여러가지 제약 사항 발생 고차함수를 사용하여 함수를 인자로 받거나 리턴한다.  캡슐화와 정보은닉 !! 클로저를 활용하면 public과 private한 값을 분리할 수 있다.\n상태를 안전하게 변경하고 유지하기 위해 사용한다. 다시말해 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.\nlet num = 0; const increase = function () { return ++num; }; console.log(increase()); console.log(increase()); console.log(increase());  카운트 상태는 increase 함수가 호출되기 전까지 변경되지 않고 유지되어야 한다. 이를 위해 카운트 상태는 increase 함수만이 변경할 수 있어야 한다.  increase 함수만이 num 변수를 참조하고 변경할 수 있게 하는 것이 바람직하다.\nconst increase = function () { let num = 0; return ++num; } console.log(increase()); //1 console.log(increase()); //1 console.log(increase()); //1 하지만 이전의 상태값을 유지하지 못한다.\nconst increase = (function() { let num = 0; return function() { return ++num; }; }()); console.log(increase()); //1 console.log(increase()); //2 console.log(increase()); //3  Reference  https://ko.javascript.info/closure  ","wordCount":"1021","inLanguage":"ko","datePublished":"2021-06-29T00:00:00Z","dateModified":"2021-06-29T00:00:00Z","author":{"@type":"Person","name":"nibble2"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://nibble2.github.io/posts/archives/javascript-deep-dive/24.-%ED%81%B4%EB%A1%9C%EC%A0%80/"},"publisher":{"@type":"Organization","name":"nibble2","logo":{"@type":"ImageObject","url":"https://nibble2.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://nibble2.github.io/ accesskey=h title="Nibble 개발 블로그✨ (Alt + H)">Nibble 개발 블로그✨</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu onscroll=menu_on_scroll()>
<li>
<a href=https://nibble2.github.io/archives title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://nibble2.github.io/categories/ title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://nibble2.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
클로저
</h1>
<div class=post-meta>June 29, 2021&nbsp;·&nbsp;nibble2
</div>
</header>
<div class=post-content><h3 id=들어가며>들어가며..<a hidden class=anchor aria-hidden=true href=#들어가며>#</a></h3>
<p>자바스크립트는 함수 지향 언어입니다. 이런 특징은 개발자에게 많은 자유도를 줍니다. 함수를 동적으로 생성할 수 있고, 생성한 함수를 다른 함수에 인수로 넘길 수 있으며, 생성된 곳이 아닌 곳에서 함수를 호출할 수도 있기 때문입니다.</p>
<p>함수 내부에서 함수 외부에 있는 변수에 접근할 수 있다는 사실은 앞서 학습해서 알고 계실 겁니다.</p>
<p><em>그런데 함수가 생성된 이후에 외부 변수가 변경되면 어떤 일이 발생할까요? 함수는 새로운 값을 가져올까요? 아니면 생성 시점 이전의 값을 가져올까요?</em></p>
<p><em>매개변수를 통해 함수를 넘기고 이 함수를 저 멀리 떨어진 코드에서 호출할 땐 어떤 일이 발생할까요? 함수는 호출되는 곳을 기준으로 외부 변수에 접근할까요?</em></p>
<p>이젠 이런 간단한 시나리오부터 시작해 좀 더 복잡한 시나리오를 다룰 수 있도록 지식을 확장해 봅시다.</p>
<p></p>
<h1 id=클로저>클로저<a hidden class=anchor aria-hidden=true href=#클로저>#</a></h1>
<p><strong>&lsquo;클로저(closure)'</strong> 는 개발자라면 알고 있어야 할 프로그래밍 용어입니다.</p>
<p><a href=https://en.wikipedia.org/wiki/Closure_(computer_programming)>클로저</a>는 <strong>외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미</strong>합니다. 몇 몇 언어에선 클로저를 구현하는 게 불가능하거나 특수한 방식으로 함수를 작성해야 클로저를 만들 수 있습니다. 하지만 자바스크립트에선 모든 함수가 자연스럽게 클로저가 됩니다. 예외가 하나 있긴 한데 자세한 내용은 <a href=https://ko.javascript.info/new-function>&lsquo;new Function&rsquo; 문법</a>에서 다루도록 하겠습니다.</p>
<p>요점을 정리해 봅시다. <strong>자바스크립트의 함수는</strong> 숨김 프로퍼티인 <code>[[Environment]]</code>를 이용해 <strong>자신이 어디서 만들어졌는지를 기억</strong>합니다. 함수 내부의 코드는 <code>[[Environment]]</code>를 사용해 <strong>외부 변수에 접근</strong>합니다.</p>
<p>프런트엔드 개발자 채용 인터뷰에서 &ldquo;클로저가 무엇입니까?&ldquo;라는 질문을 받으면, 클로저의 정의를 말하고 자바스크립트에서 왜 모든 함수가 클로저인지에 관해 설명하면 될 것 같습니다. 이때 <code>[[Environment]]</code> 프로퍼티와 렉시컬 환경이 어떤 방식으로 동작하는지에 대한 설명을 덧붙이면 좋습니다.</p>
<p></p>
<h1 id=변수의-유효범위와-클로저>변수의 유효범위와 클로저<a hidden class=anchor aria-hidden=true href=#변수의-유효범위와-클로저>#</a></h1>
<p>함수 내부에서 함수 외부에 있는 변수에 접근할 수 있다는 사실은 맞다.</p>
<p>그런데 함수가 생성된 이후에 외부 변수가 변경되면 어떤 일이 발생할까?</p>
<ol>
<li>새로운 함수를 가져온다</li>
<li>생성 시점 이전의 값을 가져온다.</li>
</ol>
<p>또한 매개변수를 통해 함수를 넘기고 이 함수를 저 멀리 떨어진 코드에서 호출할 땐 어떤 일이 발생할까? 함수는 호출 되는 곳을 기준으로 외부 변수에 접근할까?</p>
<p></p>
<h1 id=중첩함수>중첩함수<a hidden class=anchor aria-hidden=true href=#중첩함수>#</a></h1>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>makeCounter</span>() {
  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>count</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>function</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>;
  };
}

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>counter</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>makeCounter</span>();

<span style=color:#a6e22e>alert</span>( <span style=color:#a6e22e>counter</span>() ); <span style=color:#75715e>// 0
</span><span style=color:#75715e></span><span style=color:#a6e22e>alert</span>( <span style=color:#a6e22e>counter</span>() ); <span style=color:#75715e>// 1
</span><span style=color:#75715e></span><span style=color:#a6e22e>alert</span>( <span style=color:#a6e22e>counter</span>() ); <span style=color:#75715e>// 2
</span></code></pre></div><p>그런데 makeCounter를 살펴보다 보면 “counter를 여러 개 만들었을 때, 이 함수들은 서로 독립적일까? 함수와 중첩 함수 내 count 변수엔 어떤 값이 할당될까?” 같은 의문이 들기 마련입니다.</p>
<p></p>
<h1 id=렉시컬-환경>렉시컬 환경<a hidden class=anchor aria-hidden=true href=#렉시컬-환경>#</a></h1>
<h2 id=1단계-변수>1단계: 변수<a hidden class=anchor aria-hidden=true href=#1단계-변수>#</a></h2>
<blockquote>
<p>실행중인 함수, 코드블록, 스크립트 전체를 갖는다.</p>
</blockquote>
<ol>
<li>환경 레코드(Environment Record)
<ul>
<li>모든 지역 변수를 프로퍼티로 저장하고 있는 객체이다. this 값과 같은 기타 정보도 여기에 저장된다.</li>
</ul>
</li>
</ol>
<p></p>
<ol start=2>
<li>외부 렉시컬 환경(Outer Lexical Environment)에 대한 참조
<ul>
<li>외부 코드와 연관되어있음</li>
</ul>
</li>
</ol>
<blockquote>
<p>&lsquo;변수&rsquo;는 특수 내부 객체인 환경 레코드의 프로퍼티일 뿐이다.</p>
<p>변수를 가져오거나 변경 = 환경 레코드의 프로퍼티를 가져오가나 변경</p>
</blockquote>
<ul>
<li>렉시컬 환경이 하나만 존재
</li>
</ul>
<p></p>
<h3 id=-한-줄-한-줄-실행될-때마다-어떻게-변화하는지-살펴보자>👀 한 줄 한 줄 실행될 때마다 어떻게 변화하는지 살펴보자.<a hidden class=anchor aria-hidden=true href=#-한-줄-한-줄-실행될-때마다-어떻게-변화하는지-살펴보자>#</a></h3>
<p>(네모 상자: 환경 레코드 / 붉은 화살표: 외부 참조)</p>
<ol>
<li>스크립트가 시작되면 선언한 변수 전체가 렉시컬 환경에 올라간다. (pre-populated)
<ul>
<li>이때 변수의 상태는 특수 내부 상태(special internal state)인 &lsquo;uninitialized’가 됩니다. 자바스크립트 엔진은 ‘uninitialized’ 상태의 변수를 인지하긴 하지만, <code>let</code>을 만나기 전까진 이 변수를 참조할 수 없습니다.</li>
</ul>
</li>
<li>let phrase가 선언되었지만 프로퍼티 값은 undefined이다.</li>
<li>값 할당</li>
<li>값 변경</li>
</ol>
<p></p>
<p><strong>현재까지 배운 내용 요약 💁‍♀️</strong></p>
<ol>
<li>변수는 특수 내부 객체인 환경 레코드의 프로퍼티이다. 환경 레코드는 현재 실행 중인 함수와 코드 블록, 스크립트와 연관되어 있다.</li>
<li>변수를 변경하면 환경 레코드의 프로퍼티가 변경된다.</li>
</ol>
<p>렉시컬 환경은 JS가 어떻게 동작하는지 설명하는 데 쓰이는 이론상의 객체이다. 따라서 코드를 사용해 직접 렉시컬 환경을 얻거나 조작하는 것은 불가능하다.</p>
<p></p>
<h2 id=2단계-함수-선언문>2단계: 함수 선언문<a hidden class=anchor aria-hidden=true href=#2단계-함수-선언문>#</a></h2>
<p>함수 선언문으로 선언한 함수는 일반 변수와 달리 바로 초기화된다는 점에서 차이가 있다.</p>
<p>아래 스크립트에 함수를 추가했을 때 전역 렉시컬 환경 초기 상태가 어떻게 변하는지 보여준다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>say</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>name</span>)..
</code></pre></div><p>이런 동작 방식은 함수 선언문으로 정의한 함수에만 적용된다. 위와 같이 함수를 변수에 할당한 함수 표현식은 해당하지 않는다.</p>
<p></p>
<h2 id=3단계-내부와-외부-렉시컬-환경>3단계: 내부와 외부 렉시컬 환경<a hidden class=anchor aria-hidden=true href=#3단계-내부와-외부-렉시컬-환경>#</a></h2>
<p>함수를 호출해 실행하면 새로운 렉시컬 환경이 자동으로 만들어진다. 이 렉시컬 환경엔 함수 호출 시 넘겨받은 매개변수와 함수의 지역 변수가 저장된다.</p>
<p>함수가 호출 중인 동안 👀</p>
<ol>
<li>호출 중인 함수를 위한 내부 렉시컬 환경</li>
<li>내부 렉시컬 환경이 가리키는 외부 렉시컬 환경</li>
</ol>
<p>두개를 갖게 된다.</p>
<ul>
<li>
<p>내부 렉시컬 환경 - name : &ldquo;Jone&rdquo; / 현재 실행 중인 함수인 say에 상응한다.</p>
</li>
<li>
<p>외부 렉시컬 환경 - say function, phrase : &ldquo;Hello&rdquo;</p>
</li>
</ul>
<p><strong>코드에서 변수에 접근할 땐, 먼저 내부 렉시컬 환경을 검색 범위로 잡는다</strong> 내부 렉시컬 환경에서 원하는 변수를 찾지 못하면 검색 범위를 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 확장한다. 이 과정은 검색 범위가 전역 렉시컬 환경으로 확장될 때까지 반복된다.*</p>
<p>내부 렉시컬 환경에 name을 찾았지만 phrase를 찾지 못해 외부 렉시컬 환경으로 확장해 검색한다.
</p>
<p></p>
<h2 id=4단계--반환-함수>4단계 : 반환 함수<a hidden class=anchor aria-hidden=true href=#4단계--반환-함수>#</a></h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>makeCounter</span>() {
  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>count</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>function</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>;
  };
}

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>counter</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>makeCounter</span>();
</code></pre></div><p>makeCounter()를 호출하면 호출할 때 마다 새로운 렉시컬 환경 객체가 만들어진다. 그리고 이 렉시컬 환경 개체 엔 makeCounter를 실행하는데 필요한 변수들도 저장된다.</p>
<p>여기서 중첩함수(반환 함수)가 만들어지면 어떻게 될까?</p>
<p>중요한 사실 하나 ❗️</p>
<h3 id=모든-함수는-함수가-생성된-곳의-렉시컬-환경을-기억한다-><strong>모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억한다. 🤔</strong><a hidden class=anchor aria-hidden=true href=#모든-함수는-함수가-생성된-곳의-렉시컬-환경을-기억한다->#</a></h3>
<p>함수는 <code>[[Environment]]</code>라 불리는 숨김 프로퍼티를 갖는데, 여기에 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장된다.</p>
<p>따.라.서.</p>
<p>counter<code>[[Environment]]</code>엔 { counter: 0 }이 있는 렉시컬 환경에 대한 참조가 저장된다.</p>
<ol>
<li>함수가 생성될 때 딱 한 번 그 값이 세팅된다.</li>
<li>이 값은 영원히 바뀌지 않는다.</li>
</ol>
<p>실행 흐름이 중첩 함수의 본문으로 넘어오면 <code>count</code> 변수가 필요한데, 먼저 자체 렉시컬 환경에서 변수를 찾는다. 익명 중첩 함수엔 지역 변수가 없기 때문에 이 렉시컬 환경은 비어있다. 이제 <code>counter()</code>의 렉시컬 환경이 참조하는 외부 렉시컬 환경에서 <code>count</code>를 찾자.</p>
<p></p>
<p><code>count()</code>를 여러 번 호출하면 count 변수가 2, 3으로 증가하는 이유이다.</p>
<p></p>
<h1 id=가비지-컬렉션>가비지 컬렉션<a hidden class=anchor aria-hidden=true href=#가비지-컬렉션>#</a></h1>
<p>자바스크립트에서 모든 객체는 도달 가능한 상태일 때만 메모리에 유지되고 나머지는 삭제된다.</p>
<p>그런데 호출이 끝나도 여전히 도달 가능한 함수가 있을 수 있다. 이때는 중첩함수의 [[Environment]] 프로퍼티에 외부 함수에 대한 렉시컬 환경에 대한 정보가 저장된다</p>
<p>이론상으로 그렇겠지만 사실 JS엔진이 최적화를 시켜주기 때문에 신경쓰지 않아도 된다.</p>
<p>하지만 종종 디버깅 이슈가 존재한다.</p>
<p></p>
<h1 id=클로저의-활용>클로저의 활용<a hidden class=anchor aria-hidden=true href=#클로저의-활용>#</a></h1>
<h2 id=내부에서-외부-데이터를-사용하고자-할-때->내부에서 외부 데이터를 사용하고자 할 때 !!<a hidden class=anchor aria-hidden=true href=#내부에서-외부-데이터를-사용하고자-할-때->#</a></h2>
<ol>
<li>함수를 분리</li>
<li>bind 사용 ⇒ 하지만 여러가지 제약 사항 발생</li>
<li>고차함수를 사용하여 함수를 인자로 받거나 리턴한다.</li>
</ol>
<h2 id=캡슐화와-정보은닉->캡슐화와 정보은닉 !!<a hidden class=anchor aria-hidden=true href=#캡슐화와-정보은닉->#</a></h2>
<p>클로저를 활용하면 public과 private한 값을 분리할 수 있다.</p>
<p>상태를 안전하게 변경하고 유지하기 위해 사용한다. 다시말해 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>num</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>increase</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> () {
	<span style=color:#66d9ef>return</span> <span style=color:#f92672>++</span><span style=color:#a6e22e>num</span>;
};

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>increase</span>());
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>increase</span>());
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>increase</span>());
</code></pre></div><ul>
<li>카운트 상태는 increase 함수가 호출되기 전까지 변경되지 않고 유지되어야 한다.</li>
<li>이를 위해 카운트 상태는 increase 함수만이 변경할 수 있어야 한다.</li>
</ul>
<p>increase 함수만이 num 변수를 참조하고 변경할 수 있게 하는 것이 바람직하다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>increase</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> () {
	<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>num</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

	<span style=color:#66d9ef>return</span> <span style=color:#f92672>++</span><span style=color:#a6e22e>num</span>;
}

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>increase</span>()); <span style=color:#75715e>//1
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>increase</span>()); <span style=color:#75715e>//1
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>increase</span>()); <span style=color:#75715e>//1
</span></code></pre></div><p>하지만 이전의 상태값을 유지하지 못한다.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>increase</span> <span style=color:#f92672>=</span> (<span style=color:#66d9ef>function</span>() {
    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>num</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>function</span>() {
        <span style=color:#66d9ef>return</span> <span style=color:#f92672>++</span><span style=color:#a6e22e>num</span>;
    };
}());

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>increase</span>()); <span style=color:#75715e>//1
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>increase</span>()); <span style=color:#75715e>//2
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>increase</span>()); <span style=color:#75715e>//3
</span></code></pre></div><hr>
<h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1>
<ul>
<li><a href=https://ko.javascript.info/closure>https://ko.javascript.info/closure</a></li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://nibble2.github.io/tags/%ED%81%B4%EB%A1%9C%EC%A0%80/>클로저</a></li>
</ul>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share 클로저 on twitter" href="https://twitter.com/intent/tweet/?text=%ed%81%b4%eb%a1%9c%ec%a0%80&url=https%3a%2f%2fnibble2.github.io%2fposts%2farchives%2fjavascript-deep-dive%2f24.-%25ED%2581%25B4%25EB%25A1%259C%25EC%25A0%2580%2f&hashtags=%ed%81%b4%eb%a1%9c%ec%a0%80"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 클로저 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fnibble2.github.io%2fposts%2farchives%2fjavascript-deep-dive%2f24.-%25ED%2581%25B4%25EB%25A1%259C%25EC%25A0%2580%2f&title=%ed%81%b4%eb%a1%9c%ec%a0%80&summary=%ed%81%b4%eb%a1%9c%ec%a0%80&source=https%3a%2f%2fnibble2.github.io%2fposts%2farchives%2fjavascript-deep-dive%2f24.-%25ED%2581%25B4%25EB%25A1%259C%25EC%25A0%2580%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 클로저 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fnibble2.github.io%2fposts%2farchives%2fjavascript-deep-dive%2f24.-%25ED%2581%25B4%25EB%25A1%259C%25EC%25A0%2580%2f&title=%ed%81%b4%eb%a1%9c%ec%a0%80"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 클로저 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fnibble2.github.io%2fposts%2farchives%2fjavascript-deep-dive%2f24.-%25ED%2581%25B4%25EB%25A1%259C%25EC%25A0%2580%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 클로저 on whatsapp" href="https://api.whatsapp.com/send?text=%ed%81%b4%eb%a1%9c%ec%a0%80%20-%20https%3a%2f%2fnibble2.github.io%2fposts%2farchives%2fjavascript-deep-dive%2f24.-%25ED%2581%25B4%25EB%25A1%259C%25EC%25A0%2580%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share 클로저 on telegram" href="https://telegram.me/share/url?text=%ed%81%b4%eb%a1%9c%ec%a0%80&url=https%3a%2f%2fnibble2.github.io%2fposts%2farchives%2fjavascript-deep-dive%2f24.-%25ED%2581%25B4%25EB%25A1%259C%25EC%25A0%2580%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://nibble2.github.io/>nibble2</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const d=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function c(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),c();return}const a=document.createRange();a.selectNodeContents(b);const d=window.getSelection();d.removeAllRanges(),d.addRange(a);try{document.execCommand('copy'),c()}catch(a){}d.removeRange(a)}),d.appendChild(a)})</script>
</body>
</html>